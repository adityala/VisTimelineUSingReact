{"ast":null,"code":"'use strict';\n\nvar _firstTarget = null; // singleton, will contain the target element where the touch event started\n\n/**\n * Extend an Hammer.js instance with event propagation.\n *\n * Features:\n * - Events emitted by hammer will propagate in order from child to parent\n *   elements.\n * - Events are extended with a function `event.stopPropagation()` to stop\n *   propagation to parent elements.\n * - An option `preventDefault` to stop all default browser behavior.\n *\n * Usage:\n *   var hammer = propagatingHammer(new Hammer(element));\n *   var hammer = propagatingHammer(new Hammer(element), {preventDefault: true});\n *\n * @param {Hammer.Manager} hammer   An hammer instance.\n * @param {Object} [options]        Available options:\n *                                  - `preventDefault: true | false | 'mouse' | 'touch' | 'pen'`.\n *                                    Enforce preventing the default browser behavior.\n *                                    Cannot be set to `false`.\n * @return {Hammer.Manager} Returns the same hammer instance with extended\n *                          functionality\n */\nexport default function propagating(hammer, options) {\n  var _options = options || {\n    preventDefault: false\n  };\n  if (hammer.Manager) {\n    // This looks like the Hammer constructor.\n    // Overload the constructors with our own.\n    var Hammer = hammer;\n    var PropagatingHammer = function PropagatingHammer(element, options) {\n      var o = Object.create(_options);\n      if (options) Hammer.assign(o, options);\n      return propagating(new Hammer(element, o), o);\n    };\n    Hammer.assign(PropagatingHammer, Hammer);\n    PropagatingHammer.Manager = function (element, options) {\n      var o = Object.create(_options);\n      if (options) Hammer.assign(o, options);\n      return propagating(new Hammer.Manager(element, o), o);\n    };\n    return PropagatingHammer;\n  }\n\n  // create a wrapper object which will override the functions\n  // `on`, `off`, `destroy`, and `emit` of the hammer instance\n  var wrapper = Object.create(hammer);\n\n  // attach to DOM element\n  var element = hammer.element;\n  if (!element.hammer) element.hammer = [];\n  element.hammer.push(wrapper);\n\n  // register an event to catch the start of a gesture and store the\n  // target in a singleton\n  hammer.on('hammer.input', function (event) {\n    if (_options.preventDefault === true || _options.preventDefault === event.pointerType) {\n      event.preventDefault();\n    }\n    if (event.isFirst) {\n      _firstTarget = event.target;\n    }\n  });\n\n  /** @type {Object.<String, Array.<function>>} */\n  wrapper._handlers = {};\n\n  /**\n   * Register a handler for one or multiple events\n   * @param {String} events    A space separated string with events\n   * @param {function} handler A callback function, called as handler(event)\n   * @returns {Hammer.Manager} Returns the hammer instance\n   */\n  wrapper.on = function (events, handler) {\n    // register the handler\n    split(events).forEach(function (event) {\n      var _handlers = wrapper._handlers[event];\n      if (!_handlers) {\n        wrapper._handlers[event] = _handlers = [];\n\n        // register the static, propagated handler\n        hammer.on(event, propagatedHandler);\n      }\n      _handlers.push(handler);\n    });\n    return wrapper;\n  };\n\n  /**\n   * Unregister a handler for one or multiple events\n   * @param {String} events      A space separated string with events\n   * @param {function} [handler] Optional. The registered handler. If not\n   *                             provided, all handlers for given events\n   *                             are removed.\n   * @returns {Hammer.Manager}   Returns the hammer instance\n   */\n  wrapper.off = function (events, handler) {\n    // unregister the handler\n    split(events).forEach(function (event) {\n      var _handlers = wrapper._handlers[event];\n      if (_handlers) {\n        _handlers = handler ? _handlers.filter(function (h) {\n          return h !== handler;\n        }) : [];\n        if (_handlers.length > 0) {\n          wrapper._handlers[event] = _handlers;\n        } else {\n          // remove static, propagated handler\n          hammer.off(event, propagatedHandler);\n          delete wrapper._handlers[event];\n        }\n      }\n    });\n    return wrapper;\n  };\n\n  /**\n   * Emit to the event listeners\n   * @param {string} eventType\n   * @param {Event} event\n   */\n  wrapper.emit = function (eventType, event) {\n    _firstTarget = event.target;\n    hammer.emit(eventType, event);\n  };\n  wrapper.destroy = function () {\n    // Detach from DOM element\n    var hammers = hammer.element.hammer;\n    var idx = hammers.indexOf(wrapper);\n    if (idx !== -1) hammers.splice(idx, 1);\n    if (!hammers.length) delete hammer.element.hammer;\n\n    // clear all handlers\n    wrapper._handlers = {};\n\n    // call original hammer destroy\n    hammer.destroy();\n  };\n\n  // split a string with space separated words\n  function split(events) {\n    return events.match(/[^ ]+/g);\n  }\n\n  /**\n   * A static event handler, applying event propagation.\n   * @param {Object} event\n   */\n  function propagatedHandler(event) {\n    // let only a single hammer instance handle this event\n    if (event.type !== 'hammer.input') {\n      // it is possible that the same srcEvent is used with multiple hammer events,\n      // we keep track on which events are handled in an object _handled\n      if (!event.srcEvent._handled) {\n        event.srcEvent._handled = {};\n      }\n      if (event.srcEvent._handled[event.type]) {\n        return;\n      } else {\n        event.srcEvent._handled[event.type] = true;\n      }\n    }\n\n    // attach a stopPropagation function to the event\n    var stopped = false;\n    event.stopPropagation = function () {\n      stopped = true;\n    };\n\n    //wrap the srcEvent's stopPropagation to also stop hammer propagation:\n    var srcStop = event.srcEvent.stopPropagation.bind(event.srcEvent);\n    if (typeof srcStop == \"function\") {\n      event.srcEvent.stopPropagation = function () {\n        srcStop();\n        event.stopPropagation();\n      };\n    }\n\n    // attach firstTarget property to the event\n    event.firstTarget = _firstTarget;\n\n    // propagate over all elements (until stopped)\n    var elem = _firstTarget;\n    while (elem && !stopped) {\n      var elemHammer = elem.hammer;\n      if (elemHammer) {\n        var _handlers;\n        for (var k = 0; k < elemHammer.length; k++) {\n          _handlers = elemHammer[k]._handlers[event.type];\n          if (_handlers) for (var i = 0; i < _handlers.length && !stopped; i++) {\n            _handlers[i](event);\n          }\n        }\n      }\n      elem = elem.parentNode;\n    }\n  }\n  return wrapper;\n}\n;","map":{"version":3,"names":["_firstTarget","propagating","hammer","options","_options","preventDefault","Manager","Hammer","PropagatingHammer","element","o","Object","create","assign","wrapper","push","on","event","pointerType","isFirst","target","_handlers","events","handler","split","forEach","propagatedHandler","off","filter","h","length","emit","eventType","destroy","hammers","idx","indexOf","splice","match","type","srcEvent","_handled","stopped","stopPropagation","srcStop","bind","firstTarget","elem","elemHammer","k","i","parentNode"],"sources":["E:/ELSY Practice/react/node_modules/propagating-hammerjs/src/propagating.js"],"sourcesContent":["'use strict';\n\nvar _firstTarget = null; // singleton, will contain the target element where the touch event started\n\n/**\n * Extend an Hammer.js instance with event propagation.\n *\n * Features:\n * - Events emitted by hammer will propagate in order from child to parent\n *   elements.\n * - Events are extended with a function `event.stopPropagation()` to stop\n *   propagation to parent elements.\n * - An option `preventDefault` to stop all default browser behavior.\n *\n * Usage:\n *   var hammer = propagatingHammer(new Hammer(element));\n *   var hammer = propagatingHammer(new Hammer(element), {preventDefault: true});\n *\n * @param {Hammer.Manager} hammer   An hammer instance.\n * @param {Object} [options]        Available options:\n *                                  - `preventDefault: true | false | 'mouse' | 'touch' | 'pen'`.\n *                                    Enforce preventing the default browser behavior.\n *                                    Cannot be set to `false`.\n * @return {Hammer.Manager} Returns the same hammer instance with extended\n *                          functionality\n */\nexport default function propagating(hammer, options) {\n  var _options = options || {\n    preventDefault: false\n  };\n\n  if (hammer.Manager) {\n    // This looks like the Hammer constructor.\n    // Overload the constructors with our own.\n    var Hammer = hammer;\n\n    var PropagatingHammer = function(element, options) {\n      var o = Object.create(_options);\n      if (options) Hammer.assign(o, options);\n      return propagating(new Hammer(element, o), o);\n    };\n    Hammer.assign(PropagatingHammer, Hammer);\n\n    PropagatingHammer.Manager = function (element, options) {\n      var o = Object.create(_options);\n      if (options) Hammer.assign(o, options);\n      return propagating(new Hammer.Manager(element, o), o);\n    };\n\n    return PropagatingHammer;\n  }\n\n  // create a wrapper object which will override the functions\n  // `on`, `off`, `destroy`, and `emit` of the hammer instance\n  var wrapper = Object.create(hammer);\n\n  // attach to DOM element\n  var element = hammer.element;\n\n  if(!element.hammer) element.hammer = [];\n  element.hammer.push(wrapper);\n\n  // register an event to catch the start of a gesture and store the\n  // target in a singleton\n  hammer.on('hammer.input', function (event) {\n    if (_options.preventDefault === true || (_options.preventDefault === event.pointerType)) {\n      event.preventDefault();\n    }\n    if (event.isFirst) {\n      _firstTarget = event.target;\n    }\n  });\n\n  /** @type {Object.<String, Array.<function>>} */\n  wrapper._handlers = {};\n\n  /**\n   * Register a handler for one or multiple events\n   * @param {String} events    A space separated string with events\n   * @param {function} handler A callback function, called as handler(event)\n   * @returns {Hammer.Manager} Returns the hammer instance\n   */\n  wrapper.on = function (events, handler) {\n    // register the handler\n    split(events).forEach(function (event) {\n      var _handlers = wrapper._handlers[event];\n      if (!_handlers) {\n        wrapper._handlers[event] = _handlers = [];\n\n        // register the static, propagated handler\n        hammer.on(event, propagatedHandler);\n      }\n      _handlers.push(handler);\n    });\n\n    return wrapper;\n  };\n\n  /**\n   * Unregister a handler for one or multiple events\n   * @param {String} events      A space separated string with events\n   * @param {function} [handler] Optional. The registered handler. If not\n   *                             provided, all handlers for given events\n   *                             are removed.\n   * @returns {Hammer.Manager}   Returns the hammer instance\n   */\n  wrapper.off = function (events, handler) {\n    // unregister the handler\n    split(events).forEach(function (event) {\n      var _handlers = wrapper._handlers[event];\n      if (_handlers) {\n        _handlers = handler ? _handlers.filter(function (h) {\n          return h !== handler;\n        }) : [];\n\n        if (_handlers.length > 0) {\n          wrapper._handlers[event] = _handlers;\n        }\n        else {\n          // remove static, propagated handler\n          hammer.off(event, propagatedHandler);\n          delete wrapper._handlers[event];\n        }\n      }\n    });\n\n    return wrapper;\n  };\n\n  /**\n   * Emit to the event listeners\n   * @param {string} eventType\n   * @param {Event} event\n   */\n  wrapper.emit = function(eventType, event) {\n    _firstTarget = event.target;\n    hammer.emit(eventType, event);\n  };\n\n  wrapper.destroy = function () {\n    // Detach from DOM element\n    var hammers = hammer.element.hammer;\n    var idx = hammers.indexOf(wrapper);\n    if(idx !== -1) hammers.splice(idx,1);\n    if(!hammers.length) delete hammer.element.hammer;\n\n    // clear all handlers\n    wrapper._handlers = {};\n\n    // call original hammer destroy\n    hammer.destroy();\n  };\n\n  // split a string with space separated words\n  function split(events) {\n    return events.match(/[^ ]+/g);\n  }\n\n  /**\n   * A static event handler, applying event propagation.\n   * @param {Object} event\n   */\n  function propagatedHandler(event) {\n    // let only a single hammer instance handle this event\n    if (event.type !== 'hammer.input') {\n      // it is possible that the same srcEvent is used with multiple hammer events,\n      // we keep track on which events are handled in an object _handled\n      if (!event.srcEvent._handled) {\n        event.srcEvent._handled = {};\n      }\n\n      if (event.srcEvent._handled[event.type]) {\n        return;\n      }\n      else {\n        event.srcEvent._handled[event.type] = true;\n      }\n    }\n\n    // attach a stopPropagation function to the event\n    var stopped = false;\n    event.stopPropagation = function () {\n      stopped = true;\n    };\n\n    //wrap the srcEvent's stopPropagation to also stop hammer propagation:\n    var srcStop = event.srcEvent.stopPropagation.bind(event.srcEvent);\n    if(typeof srcStop == \"function\") {\n      event.srcEvent.stopPropagation = function(){\n        srcStop();\n        event.stopPropagation();\n      };\n    }\n\n    // attach firstTarget property to the event\n    event.firstTarget = _firstTarget;\n\n    // propagate over all elements (until stopped)\n    var elem = _firstTarget;\n    while (elem && !stopped) {\n      var elemHammer = elem.hammer;\n      if(elemHammer){\n        var _handlers;\n        for(var k = 0; k < elemHammer.length; k++){\n          _handlers = elemHammer[k]._handlers[event.type];\n          if(_handlers) for (var i = 0; i < _handlers.length && !stopped; i++) {\n            _handlers[i](event);\n          }\n        }\n      }\n      elem = elem.parentNode;\n    }\n  }\n\n  return wrapper;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}